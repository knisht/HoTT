\import Equiv ()
\import Equiv.Fiber
\import Function
\import HLevel
\import Logic
\import Equiv.Univalence
\import Equiv
\import Paths
\open Equiv

\data Two : \Type 1 0 | zero | one

\func AC_cartesian : \Type 3 2 =>
  \Pi  (X : \Type 2 2) (Y : X -> \Type 3 2) -> Equiv {\Pi (x : X) -> TruncP (Y x)} {TruncP (\Pi (x : X) -> Y x)}

\func stripSigmas {A : \Type -> \Type}
                  (s q : \Sigma (a : \Type) (A a))
                  (p : Contr (A s.1))
                  (r : Contr (A q.1))
  : (s = q) = (s.1 = q.1) => univalence.sec (stripSigmasEquiv {A} s q p r)

\func stripSigmasEquiv {A : \Type -> \Type}
                       (s q : \Sigma (a : \Type) (A a))
                       (p : Contr (A s.1))
                       (r : Contr (A q.1))
  : Equiv {s = q} {s.1 = q.1} =>
  \new QEquiv (sighelp {A} s q)
              (\lam s1=q1 => SigmaExt A s q s1=q1 ((inv (r.contraction (transport A s1=q1 s.2))) *> r.contraction q.2))
              (\lam v => inv (sigEqHelper {A} s q p r v))
              (\lam s1=q1 => idp)

\func sighelp {A : \Type -> \Type}
              (s q : \Sigma (a : \Type) (A a)) => (\lam (s=q : s = q) => pmap (\lam x => x.1) s=q)

\func sigEqHelper {A : \Type -> \Type}
                  (s q : \Sigma (a : \Type) (A a))
                  (p : Contr (A s.1))
                  (r : Contr (A q.1))
                  (v : s = q)
  : (v = (SigmaExt A s q (sighelp {A} s q v) ((inv (r.contraction (transport A (sighelp {A} s q v) s.2))) *> r.contraction q.2))) =>
  \let | k : s.1 = q.1 => sighelp {A} s q v
       | u : transport A k s.2 = q.2 => ((inv (r.contraction (transport A (sighelp {A} s q v) s.2))) *> r.contraction q.2)
       | z : v = SigmaExt A s q k u => matchedSigma {A} s q v k p r u
  \in z

\func ffun {A : \Type} {B : A -> \Type} (a b : A) (p : a = b) : (B a = B b) => Jl (\lam x _ => B a = B x) idp p

\func matchedSigma {A : \Type -> \Type}
                   (s q : \Sigma (a : \Type) (A a))
                   (v : s = q)
                   (k : s.1 = q.1)
                   (p : Contr (A s.1))
                   (r : Contr (A q.1))
                   (u : transport A (sighelp {A} s q v) s.2 = q.2)
--                   (pu : u = ((inv (r.contraction (transport A (sighelp {A} s q v) s.2))) *> r.contraction q.2))
  : (v = SigmaExt A s q (sighelp {A} s q v) u) =>
  \let | sg => (\lam (n : \Sigma (a : \Type) (A a)) => s = n)
       | x : sg s => idp
       | rr : sg q => v
       | match (m : \Sigma (a : \Type) (A a)) (prf : s = m) : sg m => prf
       | sigContr (sig : \Sigma (a : \Type) (A a)) (s=sig : s = sig) : Contr (A sig.1) => transport (\lam e => Contr (A e.1)) s=sig p
       | myp (sig : \Sigma (a : \Type) (A a)) (s=sig : s = sig) : transport A (sighelp {A} s sig s=sig) s.2 = sig.2 => (inv (Contr.contraction {sigContr sig s=sig} (transport A (sighelp {A} s sig s=sig) s.2))) *> (Contr.contraction {sigContr sig s=sig} (sig.2))
       | sIsProp : isProp (A s.1) => isContr=>isProp p
       | s2IsContr : Contr (s.2 = s.2) => isProp=>HLevel_-2+1 (A s.1) sIsProp (s.2) (s.2)
       | mpid : myp s idp = idp => isContr=>isProp s2IsContr (myp s idp) idp
       | y : x = SigmaExt A s s (sighelp {A} s s idp) (myp s idp) => transport (\lam refl => x = SigmaExt A s s (sighelp {A} s s idp) refl) (inv mpid) idp
       | qtmp : A q.1 => transport A (sighelp {A} s q v) s.2
       | qIsProp : isProp (A q.1) => isContr=>isProp r
       | q2IsContr : Contr (qtmp = q.2) => isProp=>HLevel_-2+1 (A q.1) qIsProp qtmp q.2
       | prp : transport A (sighelp {A} s q v) s.2 = q.2 => myp q v
       | prp2 : transport A (sighelp {A} s q v) s.2 = q.2 => u
       | mpv : (myp q v) = {qtmp = q.2} u => isContr=>isProp q2IsContr (myp q v) u
       | rrr : (v = SigmaExt A s q (sighelp {A} s q v) (myp q v)) => Jl (\lam (sig : \Sigma (a : \Type) (A a)) (patv : s = sig) => patv = SigmaExt A s sig (sighelp {A} s sig patv) (myp sig patv)) y v
       | vvv : (v = SigmaExt A s q (sighelp {A} s q v) u) => transport (\lam kek => v = SigmaExt A s q (sighelp {A} s q v) kek) mpv rrr
  \in vvv

\func TwoIsNonTrivial : Equiv {Two} {Two = Two} => \new QEquiv Two->Eq Eq->Two leftInverse rightInverse
  \where {
    \func nontrivial:Two->Two (two : Two) : Two \elim two
      | one => zero
      | zero => one

    \func nontrivial:Two->Two_is_qEquiv (x : Two) : (nontrivial:Two->Two (nontrivial:Two->Two x) = x) \elim x
      | one => idp
      | zero => idp

    \func univalent:Eq_Two_Two : Equiv {Two} {Two} =>
      \new QEquiv nontrivial:Two->Two nontrivial:Two->Two nontrivial:Two->Two_is_qEquiv nontrivial:Two->Two_is_qEquiv

    \func univalent:Two=Two : (Two = Two) => univalence.sec univalent:Eq_Two_Two

    \func Two->Eq (two : Two) : Two = Two \elim two
      | zero => idp
      | one => univalent:Two=Two

    \func Eq->Two (p : (Two = Two)) : Two => Map.f {univalence.f p} zero

    \func ident-apply {A B : \Type} (f g : A -> B) (p : f = g) (a : A) : (f a = g a) => path (\lam i => (p @ i) a)

    \func leftInverse (x : Two) : (Eq->Two (Two->Eq x) = x) \elim x
      | zero => idp
      | one => runUnivalentTwo->Two
      \where {
        \func unwrapUnivalence : (univalence.f univalent:Two=Two = {Equiv {Two} {Two}} univalent:Eq_Two_Two) =>
          Retraction.f_sec {univalence} univalent:Eq_Two_Two

        \func runUnivalentTwo->Two : (Map.f {univalence.f univalent:Two=Two} zero = one) =>
          \let | p : Map.f {univalence.f univalent:Two=Two} = nontrivial:Two->Two => pmap {Equiv {Two} {Two}} {Two -> Two} (\lam a => Map.f {a}) unwrapUnivalence
          \in ident-apply (Map.f {univalence.f univalent:Two=Two}) (nontrivial:Two->Two) p zero
      }

    \func rightInverse (p : Two = Two) : (Two->Eq (Eq->Two p) = p) => adHocRightInverse p (Eq->Two p) idp

    \func adHocRightInverse (p : Two = Two) (t : Two) (q : Eq->Two p = t) : (Two->Eq t = p) \elim t
      | zero => inv (zero:caseAnalysis p q)
      | one => inv (one:caseAnalysis p q)

    \func one:caseAnalysis (p : Two = Two) (q : Eq->Two p = one) : (p = univalent:Two=Two) =>
      one:get-univalence p (Equiv.equals (one:functionMatch p q))

    \func one:get-univalence (p : Two = Two) (q : univalence.f p = {Equiv {Two} {Two}} univalent:Eq_Two_Two) : (p = univalent:Two=Two) =>
      (inv (univalence.ret_f p)) <* pmap (univalence.sec) q

    \func one:functionMatch (p : Two = Two) (q : Eq->Two p = one) : (Map.f {univalence.f p} = nontrivial:Two->Two) =>
      funExt (\lam _ => Two) (Map.f {univalence.f p}) nontrivial:Two->Two (one:functionGeneration p q)

    \func one:functionGeneration (p : Two = Two) (q : Eq->Two p = one) (x : Two) : (Map.f {univalence.f p} x = nontrivial:Two->Two x) \elim x
      | zero => q
      | one => one:otherCase p q (Map.f {univalence.f p}) idp (Map.f {univalence.f p} one) idp

    \func one:otherCase (p : Two = Two) (q : Eq->Two p = one) (f : Two -> Two) (eq : Map.f {univalence.f p} = f) (v : Two) (vp : v = f one): (v = zero) \elim v
      | zero => idp
      | one => \let | x : Contr (Retraction f) => transport (\lam a => Contr (Retraction a)) eq (Retraction.isContr (univalence.f p))
                    | r : f zero = one => (inv (ident-apply (Map.f {univalence.f p}) f eq zero)) *> q
                    | u : f one = one => inv vp
                    | v : hasContrFibers f => transport (\lam a => hasContrFibers a) eq (Equiv=>contrFibers (univalence.f p))
                    | w : Contr (Fib f one) => v one
                    | f1 : Fib f one => Fib.make f zero r
                    | f2 : Fib f one => Fib.make f one u
                    | f=f : f1 = f2 => inv (w.contraction f1) *> (w.contraction f2)
                    | res : zero = one => transport (\lam sig => zero = sig.1) f=f idp
               \in inv res

    \func zero:get-univalence {A : \Type} (p : A = A) (q : univalence.f p = {Equiv {A} {A}} idEquiv) : (p = idp) =>
      (inv (univalence.ret_f p)) *> pmap (univalence.sec) q *> (univalence.ret_f idp)

    \func zero:caseAnalysis (p : Two = Two) (q : Eq->Two p = zero) : (p = idp) =>
      zero:get-univalence p (Equiv.equals (zero:functionMatch p q))

    \func zero:functionMatch (p : Two = Two) (q : Eq->Two p = zero) : (Map.f {univalence.f p} = id) =>
      funExt (\lam _ => Two) (Map.f {univalence.f p}) id (zero:functionGeneration p q)

    \func zero:functionGeneration (p : Two = Two) (q : Eq->Two p = zero) (x : Two) : (Map.f {univalence.f p} x = x) \elim x
      | zero => q
      | one => zero:otherCase p q (Map.f {univalence.f p}) idp (Map.f {univalence.f p} one) idp

    \func zero:otherCase (p : Two = Two) (q : Eq->Two p = zero) (f : Two -> Two) (eq : Map.f {univalence.f p} = f) (v : Two) (vp : v = f one): (v = one) \elim v
      | zero => \let | x : Contr (Retraction f) => transport (\lam a => Contr (Retraction a)) eq (Retraction.isContr (univalence.f p))
                     | r : f zero = zero => (inv (ident-apply (Map.f {univalence.f p}) f eq zero)) *> q
                     | u : f one = zero => inv vp
                     | v : hasContrFibers f => transport (\lam a => hasContrFibers a) eq (Equiv=>contrFibers (univalence.f p))
                     | w : Contr (Fib f zero) => v zero
                     | f1 : Fib f zero => Fib.make f zero r
                     | f2 : Fib f zero => Fib.make f one u
                     | f=f : f1 = f2 => inv (w.contraction f1) *> (w.contraction f2)
                     | res : zero = one => transport (\lam sig => zero = sig.1) f=f idp
                \in res
      | one => idp
  }

\func AC_contradiction (axiomOfChoice : AC_cartesian) : Empty => pureEmpty (axiomOfChoice)
  \where {
    \func _X : \Type 2 1 => \Sigma (A : \Type 1 0) (TruncP (Two = {\Set1} A))

    \func x0 : _X => (Two, inP idp)

    \func X_is_not_a_Set : \Type => (x0 = x0) = (x0.1 = x0.1)

    \func truncationIsContractible {A : \Type} (a : A) : Contr (TruncP A) =>
      Contr.make (inP a) (\lam a' => TruncP.levelProp (inP a) a')

    \func prf : ((x0 = x0) = (Two = Two)) =>
      stripSigmas {\lam a => TruncP (Two = a)} x0 x0 (truncationIsContractible idp) (truncationIsContractible idp)

    \func OneContr (p : _X = One) : (Contr (x0 = x0)) => isProp=>HLevel_-2+1 _X (XMayBeContractible p) x0 x0

    \func XMayBeContractible (p : _X = One) : (isProp _X) => transport (\lam A => isProp A) (inv p) OneIsProp

    \func ContrIsOne {A : \Type} (a : A) (p : Contr (a = a)) : Equiv {a = a} {One} =>
      \new QEquiv (\lam _ => one) (\lam _ => p.center) p.contraction (OneIsProp one)

    \func XMayBeOne (p : _X = One) : ((x0 = x0) = One) => univalence.sec (ContrIsOne x0 (OneContr p))

    \func OneMayBeTwo (p : _X = One) : (One = Two) => inv (XMayBeOne p) *> prf *> (inv (univalence.sec TwoIsNonTrivial))

    \func twoProp (p : _X = One) : (isProp Two) => transport (\lam A => isProp A) (OneMayBeTwo p) OneIsProp

    \func contradHelper (p : Two) : \Type \elim p
      | zero => One
      | Two.one => Empty

    \func contradHelper2 (p : zero = Two.one) : Empty => transport (\lam a => contradHelper a) p one

    \func contradict (p : _X = One) : Empty => contradHelper2 (twoProp p zero Two.one)

    \func _Y (x : _X) : \Type 3 1 => (x0 = x)

    \func truncated_Y (x : _X) : TruncP (_Y x) =>
      TruncP.map {Two = {\Set1} x.1} {_Y x} x.2 (\lam (proof : Two = {\Set1} x.1) => SigmaExt {\Type 1 0} (\lam (A : \Type 1 0)
      => TruncP (Two = A)) x0 x proof (TruncP.levelProp (transport (\lam A => TruncP (Two = A)) proof (inP idp)) (x.2)))

    \func Chosen_Y (choice : AC_cartesian) : TruncP (\Pi (x : _X) -> _Y x) => Map.f {choice _X _Y} truncated_Y

    \func TwoIsPropositionnalyContractible (choice : AC_cartesian) : TruncP (Contr (_X)) =>
      TruncP.map {_} {Contr _X} (Chosen_Y choice) (\lam p => Contr.make x0 p)

    \data One | one

    \func ContrIsHLevel-1 {A : \Type} (x : Contr A) : (Equiv {A} {One}) =>
      \new QEquiv (\lam _ => one) (\lam _ => x.center) (x.contraction) (oneContr)
      \where \func oneContr (a : One) : one = a \elim a | one => idp

    \func OneIsProp (a a' : One) : a = a' \elim a, a'
      | one, one => idp

    \func TruncatedXIsOne (choice : AC_cartesian) : (TruncP (_X = One)) =>
      TruncP.map (TwoIsPropositionnalyContractible choice) (\lam p => univalence.sec (ContrIsHLevel-1 p))

    \func GetEmpty (choice : AC_cartesian) : (TruncP Empty) =>
      TruncP.map (TruncatedXIsOne choice) (\lam p => contradict p)

    \func pureEmpty (choice : AC_cartesian) : Empty => TruncP.remove emptyIsProp (GetEmpty choice)

    \func emptyIsProp : isProp Empty => \lam x y => absurd x
  }